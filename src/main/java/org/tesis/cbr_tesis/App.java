package org.tesis.cbr_tesis;

import java.awt.Dimension;
import java.util.Collection;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.tesis.cbr_tesis.entities.Alert;
import org.tesis.cbr_tesis.entities.AlertCase;
import org.tesis.cbr_tesis.gui.ResultDialog;
import org.tesis.cbr_tesis.gui.RetainDialog;
import org.tesis.cbr_tesis.gui.RevisionDialog;
import org.tesis.cbr_tesis.jcolibri.similirity.DescriptionSimilarity;

import es.ucm.fdi.gaia.jcolibri.casebase.LinealCaseBase;
import es.ucm.fdi.gaia.jcolibri.cbraplications.StandardCBRApplication;
import es.ucm.fdi.gaia.jcolibri.cbrcore.Attribute;
import es.ucm.fdi.gaia.jcolibri.cbrcore.CBRCase;
import es.ucm.fdi.gaia.jcolibri.cbrcore.CBRCaseBase;
import es.ucm.fdi.gaia.jcolibri.cbrcore.CBRQuery;
import es.ucm.fdi.gaia.jcolibri.cbrcore.Connector;
import es.ucm.fdi.gaia.jcolibri.connector.DataBaseConnector;
import es.ucm.fdi.gaia.jcolibri.exception.ExecutionException;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.RetrievalResult;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.NNConfig;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.NNScoringMethod;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.similarity.global.Average;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.similarity.local.Equal;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.similarity.local.EqualsStringIgnoreCase;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.selection.SelectCases;
import es.ucm.fdi.gaia.jcolibri.method.reuse.CombineQueryAndCasesMethod;
import es.ucm.fdi.gaia.jcolibri.util.FileIO;

/**
 * App base para ejecutar el ciclo de recomendacion de alertas de vulnerabilidad!
 *
 */
public class App implements StandardCBRApplication
{

	/** Connector object */
	Connector _connector;
	/** CaseBase object */
	CBRCaseBase _caseBase;
	
	public static int newId = 0;
	
	private ResultDialog resultDialog;
	private RevisionDialog revisionDialog;
	private RetainDialog retainDialog;
	
	static JFrame main;
	private static App _instance = null;

	public static App getInstance() {
		if (_instance == null)
			_instance = new App();
		return _instance;
	}

	@Override
	public void configure() throws ExecutionException {
		try {
			// Create a data base connector
			_connector = new DataBaseConnector();
			// Init the ddbb connector with the config file
			_connector.initFromXMLfile(
					es.ucm.fdi.gaia.jcolibri.util.FileIO.findFile("org/tesis/cbr_tesis/databaseconfig.xml"));
			// Create a Lineal case base for in-memory organization
			_caseBase = new LinealCaseBase();
			
			resultDialog   = new ResultDialog(main);
			revisionDialog   = new RevisionDialog(main);
			retainDialog     = new RetainDialog(main);
			
		} catch (Exception e) {
			throw new ExecutionException(e);
		}

	}

	@Override
	public CBRCaseBase preCycle() throws ExecutionException {
		// Load cases from connector into the case base
		_caseBase.init(_connector);
		// Print the cases
		java.util.Collection<CBRCase> cases = _caseBase.getCases();
		for (CBRCase c : cases)
			System.out.println(c);
		return _caseBase;
	}

	@Override
	public void cycle(CBRQuery query) throws ExecutionException {
		// First configure the KNN
		NNConfig simConfig = new NNConfig();
		// Set the average() global similarity function for the description of the case
		simConfig.setDescriptionSimFunction(new Average());

		// The name attribute uses the equal() local similarity function
		simConfig.addMapping(new Attribute("name", AlertCase.class), new EqualsStringIgnoreCase());

		// The name attribute uses the equal() local similarity function
		simConfig.addMapping(new Attribute("type", AlertCase.class), new Equal());
		simConfig.addMapping(new Attribute("risk", AlertCase.class), new EqualsStringIgnoreCase());
		simConfig.addMapping(new Attribute("cwe", AlertCase.class), new Equal());

		simConfig.addMapping(new Attribute("description", AlertCase.class), new DescriptionSimilarity());
		
		// A bit of verbose
		System.out.println("Query Description:");
		System.out.println(query.getDescription());
		System.out.println();
		


		// Execute NN
		Collection<RetrievalResult> eval = NNScoringMethod.evaluateSimilarity(_caseBase.getCases(), query, simConfig);
		
		// Select k cases
		eval = SelectCases.selectTopKRR(eval, 2);

		// Print the retrieval
		System.out.println("Retrieved cases:");
		for (RetrievalResult nse : eval)
			System.out.println(nse);
		
		/********* Select cases **********/
		Collection<CBRCase> selectedcases = SelectCases.selectTopK(eval, 2);
		
		// Show result
		resultDialog.showCases(eval, selectedcases);
		resultDialog.setVisible(true);
		
		
		/********* Reuse *********
		// Compute a direct proportion between the "NumberOfPersons" and "Price" attributes.
		NumericDirectProportionMethod.directProportion(	new Attribute("NumberOfPersons",Alert.class), 
													 	new Attribute("price",Alert.class), 
													 	query, selectedcases);
		// Compute a direct proportion between the "Duration" and "Price" attributes.
		NumericDirectProportionMethod.directProportion(	new Attribute("Duration",Alert.class), 
			 											new Attribute("price",Alert.class), 
			 											query, selectedcases);*/
		
		
		Collection<CBRCase> newcases = CombineQueryAndCasesMethod.combine(query, selectedcases);
		System.out.println("Combined cases");
		for(CBRCase c: newcases)
			System.out.println(c);
		
		
		/********* Revise **********/		
		/*CBRCase bestCase;
		if (!newcases.isEmpty()) {
			bestCase = newcases.iterator().next();
				
			HashMap<Attribute, Object> componentsKeys = new HashMap<Attribute, Object>();
			componentsKeys.put(new Attribute("caseId", AlertCase.class), newId);
			componentsKeys.put(new Attribute("caseId", AlertSolution.class), newId);
			DefineNewIdsMethod.defineNewIdsMethod(bestCase, componentsKeys);
			System.out.println("Case with new Id");
			System.out.println(bestCase);
			
		} else {
			
			bestCase = new CBRCase();
			bestCase.setDescription(query.getDescription());
			
			AlertSolution as = new AlertSolution();
			as.setMitigation("Prueba de mitigacion");
			bestCase.setSolution(as);
			
			HashMap<Attribute, Object> componentsKeys = new HashMap<Attribute, Object>();
			componentsKeys.put(new Attribute("caseId", AlertCase.class), newId);
			componentsKeys.put(new Attribute("caseId", AlertSolution.class), newId);
			DefineNewIdsMethod.defineNewIdsMethod(bestCase, componentsKeys);
		}	*/
		
		// Revise
		//revisionDialog.showCases(newcases);
		revisionDialog.showCases(selectedcases);
		revisionDialog.setVisible(true);
		
		// Retain
		retainDialog.showCases(selectedcases, _caseBase.getCases().size());
		retainDialog.setVisible(true);
		Collection<CBRCase> casesToRetain = retainDialog.getCasestoRetain();

		// store cases into persistence
		//StoreCasesMethod.storeCase(_caseBase, bestCase);
		_caseBase.learnCases(casesToRetain);

	}

	@Override
	public void postCycle() throws ExecutionException {
		this._caseBase.close();

	}
	
	
	/*** METODOS UTILITARIOS ****/

	/**
	 * Metodo que cambia el estado de las alertas ya procesadas
	 * @param sessionFactory
	 * @param alert
	 */
	public static void changeValidatedCase(SessionFactory sessionFactory, Alert alert) {
		Session session = sessionFactory.openSession();	
		Transaction transaction = session.beginTransaction();
		
		// Se marca el caso como procesado
		int count = session.createQuery("update Alert set validated = ? WHERE alertId = ?").setParameter(0, Boolean.TRUE)
				.setParameter(1, alert.getIdAlert()).executeUpdate();

		System.out.println(count + " Record(s) Updated.");
	
		transaction.commit();
		session.close();
	}
	
	/**
	 * Obtener el name 
	 * @param name
	 * @return
	 */
	public static String getRisk(String name){
		switch(name) {
		  case "High":
			 return "High";
		  case "Medium" :
			  return "Medium";
		  case "Low":
			  //return AlertCase.RiskTypes.Low
			  return "Low";
		  default:
			  return null;
		}
	}
	

	/**
	 * Metodo encargado de iniciar el frame principal
	 */
	void showMainFrame() {
		main = new JFrame("Vulnerabilities Recommender");
		main.setResizable(false);
		main.setUndecorated(true);
		JLabel label = new JLabel(new ImageIcon(FileIO.findFile("org/tesis/cbr_tesis/images/jcolibri2.jpg")));
		main.getContentPane().add(label);
		main.pack();
		Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
		main.setBounds((screenSize.width - main.getWidth()) / 2, (screenSize.height - main.getHeight()) / 2,
				main.getWidth(), main.getHeight());
		main.setVisible(true);
	}
}
