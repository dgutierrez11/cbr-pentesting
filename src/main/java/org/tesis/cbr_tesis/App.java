package org.tesis.cbr_tesis;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.tesis.cbr_tesis.entities.Alert;
import org.tesis.cbr_tesis.entities.AlertCase;
import org.tesis.cbr_tesis.entities.AlertSolution;

import es.ucm.fdi.gaia.jcolibri.casebase.LinealCaseBase;
import es.ucm.fdi.gaia.jcolibri.cbraplications.StandardCBRApplication;
import es.ucm.fdi.gaia.jcolibri.cbrcore.Attribute;
import es.ucm.fdi.gaia.jcolibri.cbrcore.CBRCase;
import es.ucm.fdi.gaia.jcolibri.cbrcore.CBRCaseBase;
import es.ucm.fdi.gaia.jcolibri.cbrcore.CBRQuery;
import es.ucm.fdi.gaia.jcolibri.cbrcore.Connector;
import es.ucm.fdi.gaia.jcolibri.connector.DataBaseConnector;
import es.ucm.fdi.gaia.jcolibri.exception.ExecutionException;
import es.ucm.fdi.gaia.jcolibri.method.retain.StoreCasesMethod;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.RetrievalResult;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.NNConfig;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.NNScoringMethod;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.similarity.global.Average;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.similarity.local.Equal;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.NNretrieval.similarity.local.EqualsStringIgnoreCase;
import es.ucm.fdi.gaia.jcolibri.method.retrieve.selection.SelectCases;
import es.ucm.fdi.gaia.jcolibri.method.reuse.CombineQueryAndCasesMethod;
import es.ucm.fdi.gaia.jcolibri.method.revise.DefineNewIdsMethod;

/**
 * Hello world!
 *
 */
public class App implements StandardCBRApplication
{

	/** Connector object */
	Connector _connector;
	/** CaseBase object */
	CBRCaseBase _caseBase;
	
	private static int newId = 0;

	@Override
	public void configure() throws ExecutionException {
		try {
			// Create a data base connector
			_connector = new DataBaseConnector();
			// Init the ddbb connector with the config file
			_connector.initFromXMLfile(
					es.ucm.fdi.gaia.jcolibri.util.FileIO.findFile("org/tesis/cbr_tesis/databaseconfig.xml"));
			// Create a Lineal case base for in-memory organization
			_caseBase = new LinealCaseBase();
		} catch (Exception e) {
			throw new ExecutionException(e);
		}

	}

	@Override
	public CBRCaseBase preCycle() throws ExecutionException {
		// Load cases from connector into the case base
		_caseBase.init(_connector);
		// Print the cases
		java.util.Collection<CBRCase> cases = _caseBase.getCases();
		for (CBRCase c : cases)
			System.out.println(c);
		return _caseBase;
	}

	@Override
	public void cycle(CBRQuery query) throws ExecutionException {
		// First configure the KNN
		NNConfig simConfig = new NNConfig();
		// Set the average() global similarity function for the description of the case
		simConfig.setDescriptionSimFunction(new Average());

		// The name attribute uses the equal() local similarity function
		simConfig.addMapping(new Attribute("name", Alert.class), new EqualsStringIgnoreCase());

		// The name attribute uses the equal() local similarity function
		simConfig.addMapping(new Attribute("type", Alert.class), new Equal());
		simConfig.addMapping(new Attribute("risk", Alert.class), new Equal());
		simConfig.addMapping(new Attribute("cwe", Alert.class), new Equal());

		// A bit of verbose
		System.out.println("Query Description:");
		System.out.println(query.getDescription());
		System.out.println();

		// Execute NN
		Collection<RetrievalResult> eval = NNScoringMethod.evaluateSimilarity(_caseBase.getCases(), query, simConfig);

		// Select k cases
		eval = SelectCases.selectTopKRR(eval, 2);

		// Print the retrieval
		System.out.println("Retrieved cases:");
		for (RetrievalResult nse : eval)
			System.out.println(nse);
		
		/********* Select cases **********/
		Collection<CBRCase> selectedcases = SelectCases.selectTopK(eval, 1);
		
		/********* Reuse *********
		// Compute a direct proportion between the "NumberOfPersons" and "Price" attributes.
		NumericDirectProportionMethod.directProportion(	new Attribute("NumberOfPersons",Alert.class), 
													 	new Attribute("price",Alert.class), 
													 	query, selectedcases);
		// Compute a direct proportion between the "Duration" and "Price" attributes.
		NumericDirectProportionMethod.directProportion(	new Attribute("Duration",Alert.class), 
			 											new Attribute("price",Alert.class), 
			 											query, selectedcases);*/
		
		
		Collection<CBRCase> newcases = CombineQueryAndCasesMethod.combine(query, selectedcases);
		System.out.println("Combined cases");
		for(CBRCase c: newcases)
			System.out.println(c);
		
		
		/********* Revise **********/		
		CBRCase bestCase;
		if (!newcases.isEmpty()) {
			bestCase = newcases.iterator().next();
				
			HashMap<Attribute, Object> componentsKeys = new HashMap<Attribute, Object>();
			componentsKeys.put(new Attribute("caseId", AlertCase.class), newId);
			componentsKeys.put(new Attribute("caseId", AlertSolution.class), newId);
			DefineNewIdsMethod.defineNewIdsMethod(bestCase, componentsKeys);
			System.out.println("Case with new Id");
			System.out.println(bestCase);
			
		} else {
			
			bestCase = new CBRCase();
			bestCase.setDescription(query.getDescription());
			
			AlertSolution as = new AlertSolution();
			as.setMitigation("Prueba de mitigacion");
			bestCase.setSolution(as);
			
			HashMap<Attribute, Object> componentsKeys = new HashMap<Attribute, Object>();
			componentsKeys.put(new Attribute("caseId", AlertCase.class), newId);
			componentsKeys.put(new Attribute("caseId", AlertSolution.class), newId);
			DefineNewIdsMethod.defineNewIdsMethod(bestCase, componentsKeys);
		}		

		// store cases into persistence
		StoreCasesMethod.storeCase(_caseBase, bestCase);

	}

	@Override
	public void postCycle() throws ExecutionException {
		this._caseBase.close();

	}

	public static void main(String[] args) {
		// Launch DDBB manager

		App appTest = new App();
		try {
			appTest.configure();
			appTest.preCycle();

			
			// Consultar vulnerabilidad como query para recomendar solucion
	        Configuration hbconfig = new Configuration();
	        hbconfig.configure("org/tesis/cbr_tesis/hibernate.cfg.xml");
	        SessionFactory sessionFactory = hbconfig.buildSessionFactory();
	        
	        Session session = sessionFactory.openSession();	
	        Transaction transaction = session.beginTransaction();
	        
			@SuppressWarnings("unchecked")
			List<Alert> descList = session.createQuery("from Alert WHERE validated = :validated")
					.setParameter("validated", Boolean.FALSE).getResultList();
			
			transaction.commit();
			session.close();

			// BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
			for (Alert alert : descList) {

				/********* Query Definition **********/
				AlertCase queryDesc = new AlertCase();
				queryDesc.setName(alert.getName());
				queryDesc.setDescription(alert.getDescription());
				queryDesc.setRisk(getRisk(alert.getRisk()));
				queryDesc.setCwe(alert.getCwe());
				queryDesc.setCweCategory("CweCategory");
				queryDesc.setOwaspCategory("OwaspCategory");
				// Crear campos y entidad con solution
				CBRQuery query = new CBRQuery();
				query.setDescription(queryDesc);

				App.newId = alert.getIdAlert().intValue();
				appTest.cycle(query);
				
			    changeValidatedCase(sessionFactory, alert);
				
				System.out.println("Cycle finished");
			}		
			appTest.postCycle();
			System.exit(1);
		} catch (ExecutionException e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.exit(1);
		}
	}

	private static void changeValidatedCase(SessionFactory sessionFactory, Alert alert) {
		Session session = sessionFactory.openSession();	
		Transaction transaction = session.beginTransaction();
		
		// Se marca el caso como procesado
		int count = session.createQuery("update Alert set validated = ? WHERE alertId = ?").setParameter(0, Boolean.TRUE)
				.setParameter(1, alert.getIdAlert()).executeUpdate();

		System.out.println(count + " Record(s) Updated.");
	
		transaction.commit();
		session.close();
	}
	
	private static String getRisk(String name){
		switch(name) {
		  case "High":
			 return "High";
		  case "Medium" :
			  return "Medium";
		  case "Low":
			  //return AlertCase.RiskTypes.Low
			  return "Low";
		  default:
			  return null;
		}
	}
}
